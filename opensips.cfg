####### Global Parameters #########

debug_mode=yes

log_level=3
xlog_level=3
# para ver logs no console (stderr) - bom para testes
log_stderror=yes
log_facility=LOG_LOCAL0 # Mantenha isso para enviar logs para syslog também, caso você configure um depois.

udp_workers=4

listen=udp:0.0.0.0:5060   # CUSTOMIZE ME

####### Modules Section ########

#set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "working_mode_preset", "single-instance-no-db")

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")

#### ACCounting module
loadmodule "acc.so"
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 0)
/* by default we do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure to enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)

loadmodule "proto_udp.so"

#### AUTH module
loadmodule "auth.so"

#### AUTH_AAA module
loadmodule "auth_aaa.so"
modparam("auth_aaa", "aaa_url", "radius://127.0.0.1:1812/testing123")
modparam("auth_aaa", "use_domain", "no")

####### Routing Logic ########

# main request routing logic

route{

        xlog("L_INFO", "Rota inicial - /$si/$fU/$rU/$fd/$ci");

        if (!mf_process_maxfwd_header(10)) {
                send_reply(483,"Too Many Hops");
                exit;
        }

        if (has_totag()) {

                # handle hop-by-hop ACK (no routing required)
                if ( is_method("ACK") && t_check_trans() ) {
                        t_relay();
                        exit;
                }

                # sequential request within a dialog should
                # take the path determined by record-routing
                if ( !loose_route() ) {
                        # we do record-routing for all our traffic, so we should not
                        # receive any sequential requests without Route hdr.
                        send_reply(404,"Not here");
                        exit;
                }

                if (is_method("BYE")) {
                        # do accounting even if the transaction fails
                        do_accounting("log","failed");
                }

                # route it out to whatever destination was set by loose_route()
                # in $du (destination URI).
                route(relay);
                exit;
        }

        # CANCEL processing
        if (is_method("CANCEL")) {
                if (t_check_trans())
                        t_relay();
                exit;
        }

        # absorb retransmissions, but do not create transaction
        t_check_trans();

        if (is_method("INVITE|SUBSCRIBE|MESSAGE")) {
            if (!auth_check("$fd", "subscriber", "1")) {
                auth_challenge("$fd", "1");
                exit;
            }
        }
        
        # authenticate requests
        if (is_method("REGISTER")) {
            if ($au == "teste" && $ap == "123") {
                # authentication successful
                xlog("L_INFO", "Authentication successful for user $au\n");
            } else {
                # authentication failed
                xlog("L_ERR", "Authentication failed for user $au\n");
                send_reply(401, "Unauthorized");
                exit;
            }
        }

        # Redirecionamento de todas as chamadas
        xlog("L_INFO", "Redirecionando chamada de $fu para $ru");
        $rd = "5t4n6j0wnrl.sip.livekit.cloud";
        $ru = "sip:" + $rU + "@" + $rd;       
        xlog("L_INFO", "Redirecionando chamada para $ru");
        route(relay);
        exit;
}

route[relay] {
        xlog("L_INFO", "Entrando na rota relay, encaminhando para $ru");
        if (!t_relay_to_udp("$ru", "5060")) {
                send_reply(500,"Internal Error");
        }
        exit;
}

branch_route[per_branch_ops] {
        xlog("new branch at $ru\n");
}

onreply_route[handle_nat] {
        xlog("incoming reply\n");
}

failure_route[missed_call] {
        if (t_was_cancelled()) {
                exit;
        }
}
